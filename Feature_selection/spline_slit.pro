;PURPOSE:
;;;; ------------------------------------------------------------------
;;;| This file contains all the required routines to track a solar    |
;;;| feature by fitting a curve to the general position of the feature|
;;;| and checking the value around the fitted curve in time.          |
;;; ------------------------------------------------------------------
;
;spline_slit,data,slits=slits,frames=frames,$
;                        pickn=pickn,distance=distance,anchor=anchor,$
;                        gpoints=gpoints,spacing=spacing, $
;                        oversample=oversample,plot_slit=plot_slit,vector=vector,curvepoints=curvepoints,intim=intim
;; 
;INPUTS: data - data cube
;                
;
;OPTIONAL INPUTS - distance - half length of TD slit, default = 10
;
;                  frames - image used for point selection is average of entire data set, enter array [t1,t2]
;                           to select frames for averaging
;
;                  pickn - If set, will use the procedure 'pick_n' to enable
;;                 the user to select points by clicking on an
;;                 image. This procedure requires an image and so one
;;                 must be supplied with the 'imagename'
;;                 keyword. This should be set to number of points required to spline to.
;
;                  gpoints  - Guide values for/from spline fit. Can be used in two ways:
;                  1) Give the spline points values instead of picking them with pickn The value
;;                 of 'gpoints' must be an array of dimensions (N,2).
;                  If both 'gpoints' and 'pickn' are set, the values of
;;                'gpoints' will be ignored and overwritten.
;                  2) Returns the values from the picking of points - used with /pickn
;
;                  vector - overplots normal vectors, i.e. indicates TD direction
;
;                  spacing - Scalar value that gives the spacing between points
;;                 on the fitted curve. If unset, the default spacing
;;                 will be used in accordance with the IDL routine
;;                 'spline_p'. NOTE: spline_p intervals typically do not give the desired spacing value (normally smaller values)
;                  To get intervals close to desired spacing, use oversample 
;
;                  oversample - over samples the curve in spline_p by 10^oversample - obviously large values of oversample
;                               will take a long time
;                  anchor - will use first and last selected points as anchor points for defining a curve, not used in
;                           slit extraction. 
;
;                  intim - provide an image to use for picking the guide points, e.g., unsharp mask image
;
;OUTPUTS - curvepoints - spline data points
;          slits - cube of time distance diagrams
;          gpoints - selected points from pickn
;          
;
;CALL PROCEDURE: spline_slit,data,pickn=6,slits=slits,gpoints=gpoints - if picking points from image, returns picked
;                   values to gpoints
;                spline_slit,data,gpoints=gpoints - if data points for spline-ing known 
;
;CALLS: solcurvefit.pro, pick.pro, pick_n.pro, tvim.pro, partvelvec.pro, image_interpolate.pro
;
;
;HISTORY: Author: Oliver Scott (Unless otherwise stated) 06/2015
;                 Removed redundant code, added common variables, removed/added some keywords - RJM 11/2015
;
;TO DO: * Use mouse to bring point picking to end rather than entering
;          number at command line
;
;


;########################################################################################
;;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;;;
;; The procedure takes an image, displays it, and allows you to click 
;; the image a user specified number of times.
;; The coordinates of these points are output.
;;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;;;

FUNCTION pick_n,n

COMMON SOLVAR,imagesum, times

;; Plot Image
tvim,imagesum,title='Sum of the images from time '+strcompress(arr2str(times[0]),/remove_all)+$
     ' to time '+strcompress(arr2str(times[1]),/remove_all)+'.'

;; Initalise output array
gpoints=make_array(n,2)

print,'Pick '+strcompress(n)+' points to make track'

;; Use the 'pick' procedure the user specified number of times, store output
for i=0,n-1 do begin
   pick,xpoint,ypoint,/doplot,/noprint
   gpoints[i,*]=[[xpoint],[ypoint]]
endfor

return,gpoints

END

;########################################################################################
;;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;;;
;;
;; The following procedure calls upon the interpolate function
;;
;; The procedure takes a time slice of the image data and the points
;; and normal vector to those points (in the format as generated by
;; the procedure solcurvefit.
;;
;; The output of the procedure is points along the normals along d3,
;; in order of row 0 giving x values, row 1 giving y values, row 2
;; gives the interpolated image intensity at the point given by the
;; corresponding x,y point.
;;
;; Default length of line is 10 units along the normal in each direction.
;; use the keyword d to define a different length in each direction.
;;
;;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;;;

PRO image_interpolate,imagetimeslice,gpoints,imagelines,interp_mat,d=d,plot_slit=plot_slit

length=size(gpoints)
length=length[1]
imagelines=make_array(length,3,2*d+1)
interp_mat=make_array(length,2*d+1)


FOR i=0,length-1 DO BEGIN
   imagelines[i,0,*]=(gpoints[i,0]-d*gpoints[i,3])+2*d*gpoints[i,3]*findgen(2*d+1)/(2*d)
   imagelines[i,1,*]=(gpoints[i,1]-d*gpoints[i,4])+2*d*gpoints[i,4]*findgen(2*d+1)/(2*d)
   interp_mat[i,*]=interpolate(imagetimeslice,imagelines[i,0,*],imagelines[i,1,*],cubic=-0.5)
   imagelines[i,2,*]=interp_mat[i,*]
   IF keyword_set(plot_slit) THEN oplot,imagelines[i,0,*],imagelines[i,1,*]  

ENDFOR

END


;########################################################################################
;;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;;;
;;
;; The procedure performs parametric spline fitting to a data set that
;; is input either through inputting an array of points, or by using a
;; procedure to allow the user to place points onto an image directly.
;;
;; Once a curve is fit to the data, the procedure calculates the
;; differential of the curve (dy/dx) using centred finite differences
;; (forward finite differences and backwards finite differences used
;; for the first and last points respectively). The differential at
;; each point is used to calculate the gradient of the normal vector
;; at each point in the fitted curve. Subsequent unit normal vectors
;; are then calculated for each point.
;;
;;; Procedure Arguments 
;;
;;    spline_arr - A two dimensional array containing x,y values of
;;                 the fitted curve
;;    
;;    normal_arr  - A two dimensional array containing x,y values of
;;                 points, the differential to the curve at these
;;                 points, and the unit normal vector to the
;;                 curve at these points
;;
;;                 These values are stored in rows, thus the first two
;;                 rows give the x,y values respectively; the next row
;;                 gives the differential of the curve at the
;;                 corresponding point;and the next two rows give the
;;                 x and y components of the unit normal vector at the 
;;                 corresponding point.
;;
;;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;;;

pro solcurvefit,spline_arr,normal_arr,diffvec $
               ,spacing=spacing,vector=vector,pickn=pickn,gpoints=gpoints,oversample=oversample,$
                xvec,yvec


COMMON SOLVAR, imagesum, times


IF n_elements(pickn) GT 0 THEN BEGIN
   gpoints=pick_n(pickn)
   ; data vectors extracted from data array
   xvec=gpoints[*,0]
   yvec=gpoints[*,1]

ENDIF ELSE BEGIN

   ;; Check for valid array size and orientation
   ; Do note the edge case of when N=2 : it is possible for the data to
   ; be inputted incorrectly but there is no method to check this.

    arraysizes=size(gpoints)
   
    IF NOT arraysizes[0] EQ 2 THEN message,'Data gpoints array is of the wrong dimensions. Please input an array of dimensions (N,2).' $
    ELSE IF NOT (arraysizes[2] eq 2) OR (arraysizes[1] eq 2) THEN message, 'Data array is of the wrong dimensions. Please input an array of dimensions (N,2).' $
    ELSE IF NOT arraysizes[2] eq 2 THEN gpoints=transpose(gpoints)

    ; Data vectors extracted from data array

     xvec=gpoints[*,0]
     yvec=gpoints[*,1]

     ;; Finds data plot range for x and y if using supplied data array
     ;; without an image supplied
     ; ranges found by extending the x and y ranges by 50% centred around
      ; central value for x and y respectively.

     ; for x
     xmin=min(xvec,max=xmax)
     oxrange=[xmin,xmax] ; original x range stored
     xrange=xmax-xmin
     xmid=0.5*(xmin+xmax)
     xmin=xmid-0.75*xrange
     xmax=xmid+0.75*xrange

     ; for y
     ymin=min(yvec,max=ymax)
     oyrange=[ymin,ymax] ; original y range stored
     yrange=ymax-ymin
     ymid=0.5*(ymin+ymax)
     ymin=ymid-0.75*yrange
     ymax=ymid+0.75*yrange

     tvim,imagesum
     oplot,xvec,yvec,psym=1

     
ENDELSE 





;;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;;;


;;; Parametric Splining


IF n_elements(spacing) GT 0 THEN BEGIN
   IF n_elements(oversample) GT 0 THEN BEGIN
   
      ;; Oversampling works by setting the spacing to be smaller to make the
      ;; point density larger. Then by summing the lengths between the
      ;; points together to make up the original desired length the correct
      ;; point spacing is achieved while reducing the impact of any error in
      ;; the splining routine.
      ;; 
      ;; The check for when the inter-point distance (from oversampled
      ;; curve) has reached the desired spacing is achieved by finding the
      ;; cumulative distance along the (oversampled) curve. Then by dividing
      ;; this cumulative distance vector by the original sampling it is
      ;; apparent that every time the desired original spacing is found the
      ;; floor of the cumulative distance will increase by 1. Flooring has
      ;; been achieved by changing variable type to integer. Creating a
      ;; logical vector that is true when the respective element in the
      ;; floored cumulative distance vector increases by 1. This logical
      ;; vector is used to sample points in the oversampled curve, achieving
      ;; the original interpoint spacing as desired, with reduced errors.

      ospacing=spacing
      spacing=double(spacing)/(10^oversample)
      
      spline_p,xvec,yvec,xsplines,ysplines,interval=spacing

      point_num=size(xsplines,/n_elements) ; find length of vector
      spline_arr=[[xsplines],[ysplines]]
   
      ;linear distance between spline points
      diff_vec=sqrt( (shift(spline_arr[*,0],-1)-spline_arr[*,0])^2+(shift(spline_arr[*,1],-1)-spline_arr[*,1])^2)
      diff_vec=[0,diff_vec[0:point_num-2]]

      cum_diff_vec=diff_vec ; initalise this vector just by duplication as it needs to be the same size
      FOR i=0,point_num-1 DO cum_diff_vec[i]=total(diff_vec[0:i]) 

      cum_diff_vec=cum_diff_vec/ospacing

      cum_diff_vec=ULONG64(cum_diff_vec)

      logical_vec=cum_diff_vec
      FOR i=1,point_num-1 DO logical_vec[i]=(cum_diff_vec[i] ne cum_diff_vec[i-1])
      logical_vec[0]=1

      xsplines=xsplines[where(logical_vec eq 1)]
      ysplines=ysplines[where(logical_vec eq 1)]

   ENDIF ELSE spline_p,xvec,yvec,xsplines,ysplines,interval=spacing ; use splines_p routine to generate spline interpolation points
ENDIF ELSE spline_p,xvec,yvec,xsplines,ysplines



oplot,xsplines,ysplines,psym=0

spline_arr=[[xsplines],[ysplines]]



;;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;;;
;;; Calculation of Unit Normal Vectors
;; find finite differences

pointnum=n_elements(xsplines)

; initalise vector to store differences
tan_arr=make_array(pointnum,2,/float) ; array of tangent vectors between points
norm_arr=make_array(pointnum,2,/float) ; array of normals at each point

; use forward and backward differences on first and last elements where centred difference is ill defined
tan_arr[0,*]=[[xsplines[1]-xsplines[0]],[ysplines[1]-ysplines[0]]]
tan_arr[pointnum-1,*]=[[xsplines[pointnum-1]-xsplines[pointnum-2]],[ysplines[pointnum-1]-ysplines[pointnum-2]]]

; array manipulation for centred finite differences
tan_arr[1:pointnum-2,*]=[[xsplines[2:pointnum-1]-xsplines[0:pointnum-3]],[ysplines[2:pointnum-1]-ysplines[0:pointnum-3]]]


;; create normals by finding gradients and creating vectors
; initalisation of array of normal vectors

diff_arr=tan_arr[*,1]/tan_arr[*,0]

; this loop creates the normals
FOR i=0,pointnum-1 DO BEGIN
   IF (diff_arr[i] eq 0) THEN norm_arr[i,*]=[[0],[1]] $
      ELSE norm_arr[i,*]=(1/sqrt(1+(-1/diff_arr[i])^2))*[[1],[-1/diff_arr[i]]]

   ; this check uses the crossproduct to ensure correct orientation of normals
   IF tan_arr[i,0]*norm_arr[i,1] LT tan_arr[i,1]*norm_arr[i,0] THEN norm_arr[i,*]=-norm_arr[i,*] 
ENDFOR

normal_arr=[[spline_arr],[diff_arr],[norm_arr]]

IF keyword_set(vector) THEN partvelvec,norm_arr[*,0],norm_arr[*,1],spline_arr[*,0],spline_arr[*,1],/over,VecColor='green'


diffvec=sqrt(((spline_arr[1:pointnum-1,0]-spline_arr[0:pointnum-2,0])^2)+((spline_arr[1:pointnum-1,1]-spline_arr[0:pointnum-2,1])^2))

END





;########################################################################################
;MAIN ROUTINE

PRO spline_slit,data,slits=slits,frames=frames,$
                        pickn=pickn,distance=distance,anchor=anchor,$
                        gpoints=gpoints,spacing=spacing, $
                        oversample=oversample,plot_slit=plot_slit,vector=vector,curvepoints=curvepoints,intim=intim

COMMON SOLVAR, imagesum, times
on_error,2

;;; Keyword Checks
IF n_elements(distance) EQ 0 THEN distance=10
IF n_elements(data) EQ 0 THEN message,'Need data'
IF n_elements(gpoints) EQ 0 && n_elements(pickn) EQ 0 THEN $
   message,'Please either input a data set using keyword ''gpoints'' or ''pickn'' to allow you to pick a number of points from the supplied image'
IF n_elements(pickn) gt 0 && n_elements(gpoints) gt 0 THEN $
print,'Ignoring supplied points due to presence of ''pickn'' keyword. Using both will cause the point pick process to override the inputted array.'
IF n_elements(pickn) GT 0 && pickn LT 2 THEN message, 'Need at least two points for spline fitting'  


lengths=size(data)
nx=lengths(1) & ny=lengths(2) & nt=lengths[3]


IF n_elements(frames) EQ 0 THEN times=[0,nt-1] ELSE times=[frames[0],frames[1]]

IF n_elements(intim) GT 0 THEN imagesum=intim ELSE imagesum=total(data[*,*,times[0]:times[1]],3)


; uses the solcurvefit procedure to fit a curve to the feature
solcurvefit,spline_arr,normal_arr,diffvec,spacing=spacing,vector=vector,pickn=pickn,oversample=oversample,gpoints=gpoints,$
            xvec,yvec


curvepoints=spline_arr
lengths=size(curvepoints)
num_points=lengths[1]

IF keyword_set(anchor) THEN BEGIN
   
  ;Define circle that passes through loop footpoints
    vecsize=n_elements(xvec)
    cutoff=[xvec[1],yvec[1]]
    cutoff2=[xvec[vecsize-2],yvec[vecsize-2]]
  
    r=sqrt((cutoff2[0]-cutoff[0])^2+(cutoff2[1]-cutoff[1])^2) 
    mid=[cutoff2[0]+cutoff[0],cutoff2[1]+cutoff[1]]/2 ;midpoint between footpoints
    

    cx=mid[0]-sqrt(r^2-(r/2)^2)*(cutoff[1]-cutoff2[1])/r
    cy=mid[1]-sqrt(r^2-(r/2)^2)*(cutoff2[0]-cutoff[0])/r
    

    ;define polar array
    pol=fltarr(nx,ny,2)
    x=findgen(nx) & y=findgen(ny)
    x=rebin(x,nx,ny)
    y=transpose(rebin(y,ny,nx))
 
    pol[*,*,0]=sqrt((x-cx)^2+(y-cy)^2)
    pol[*,*,1]=atan((y-cy)/(x-cx))

    sp_pol=sqrt((curvepoints[*,0]-cx)^2+(curvepoints[*,1]-cy)^2)
    in=where(sp_pol GE r,complement=in2)
;   IF n_elements(in) GT in2 THEN 
       
    curvepoints=curvepoints[in,*]
    normal_arr=normal_arr[in,*]

ENDIF


lengths=size(curvepoints)
num_points=lengths[1]

; initalises array
interp_arr=make_array(num_points,2*distance+1,nt)


FOR i=0,nt-1 DO BEGIN
   image_interpolate,data[*,*,i],normal_arr,imagelines,interp_mat,d=distance,plot_slit=plot_slit
   interp_arr[*,*,i]=interp_mat
ENDFOR

slits=transpose(interp_arr,[1,2,0])


END










